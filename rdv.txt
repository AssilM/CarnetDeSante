# PLAN D'ACTION DÉTAILLÉ: GESTION DES RENDEZ-VOUS EN COURS
========================================================

## CONTEXTE DU PROJET
----------------------
Application CarnetDeSante avec fonctionnalité de gestion des rendez-vous pour médecins.
Éléments déjà implémentés:
- Colonne notes_medecin dans la table rendez_vous
- Statut en_cours ajouté aux valeurs possibles
- Table d'association documents_rendez_vous
- Logique frontend pour extraire les rendez-vous à venir et imminents

## OBJECTIFS
------------
- Afficher le statut des rendez-vous (à venir, en cours, terminé)
- Intégrer un timer pour le temps restant
- Fournir une interface spéciale pour gérer les rendez-vous en cours (notes, documents)

## PLAN D'ACTION EN 4 PHASES
---------------------------

### PHASE 1: ROUTES API BACKEND (1-2 jours)
-----------------------------------------

#### 1.1. PRÉPARATION DE L'ARCHITECTURE (CRITIQUE)
- 1.1.1. Créer des constantes pour les statuts de rendez-vous (à venir, en_cours, annulé, terminé)
- 1.1.2. Définir les modèles de validation pour chaque nouvelle route
- 1.1.3. Mettre à jour la documentation Swagger des routes

#### 1.2. ROUTES POUR LA GESTION DES STATUTS (CRITIQUE)
- 1.2.1. PUT /api/rendez-vous/:id/en-cours
  • Implémenter middleware d'authentification (authenticate)
  • Implémenter middleware d'autorisation (authorize('medecin'))
  • Ajouter middleware checkRendezVousOwnership
  • Valider que le rendez-vous existe et peut être mis en cours (pas terminé/annulé)
  • Enregistrer l'heure de début réelle du rendez-vous
  • Journaliser l'action pour audit médical

- 1.2.2. PUT /api/rendez-vous/:id/termine
  • Implémenter middleware d'authentification (authenticate)
  • Implémenter middleware d'autorisation (authorize('medecin'))
  • Ajouter middleware checkRendezVousOwnership
  • Valider que le rendez-vous existe et est actuellement en cours
  • Enregistrer l'heure de fin réelle du rendez-vous
  • Calculer et stocker la durée réelle du rendez-vous
  • Journaliser l'action pour audit médical

- 1.2.3. GET /api/rendez-vous/en-cours
  • Récupérer tous les rendez-vous en cours du médecin connecté
  • Implémenter pagination pour grande quantité de données

#### 1.3. ROUTE POUR LA GESTION DES NOTES (CRITIQUE)
- 1.3.1. PUT /api/rendez-vous/:id/notes
  • Implémenter middleware d'authentification (authenticate)
  • Implémenter middleware d'autorisation (authorize('medecin'))
  • Ajouter middleware checkRendezVousOwnership
  • Valider le contenu des notes (longueur, format, caractères spéciaux)
  • Stocker l'historique des modifications (qui, quand)
  • Implémenter transactions SQL pour garantir l'atomicité
  • Chiffrer les notes sensibles en base de données
  • Journaliser l'accès et les modifications pour audit médical

#### 1.4. ROUTES POUR LA GESTION DES DOCUMENTS (HAUTE)
- 1.4.1. POST /api/rendez-vous/:id/documents
  • Implémenter middleware d'authentification (authenticate)
  • Implémenter middleware d'autorisation (authorize('medecin'))
  • Ajouter middleware checkRendezVousOwnership
  • Valider que le document existe et appartient au patient concerné
  • Utiliser des transactions SQL pour l'association document-rendezvous
  • Journaliser l'association pour audit médical

- 1.4.2. GET /api/rendez-vous/:id/documents
  • Implémenter middleware d'authentification (authenticate)
  • Implémenter middleware d'autorisation (authorize(['medecin', 'patient']))
  • Ajouter middleware checkRendezVousOwnership
  • Pagination des résultats
  • Filtrage par type de document

- 1.4.3. DELETE /api/rendez-vous/:id/documents/:documentId
  • Implémenter middleware d'authentification (authenticate)
  • Implémenter middleware d'autorisation (authorize('medecin'))
  • Ajouter middleware checkRendezVousOwnership
  • Vérifier que l'association existe avant suppression
  • Ne supprimer que l'association, pas le document lui-même
  • Journaliser la dissociation pour audit médical

#### 1.5. SERVICE DE MISE À JOUR DES STATUTS (MOYENNE)
- 1.5.1. Évaluer les approches possibles
  • Comparer cron job vs WebSockets vs Server-Sent Events (SSE)
  • Analyser les implications en termes de performance et scalabilité
  • Choisir la solution la plus adaptée (WebSockets recommandés)

- 1.5.2. Implémentation de WebSockets pour mises à jour en temps réel
  • Configurer socket.io ou équivalent côté serveur
  • Définir les événements et leur structure
  • Mettre en place des mécanismes pour éviter les conflits de mise à jour
  • Implémenter heartbeat pour détecter les déconnexions
  • Ajouter mécanisme de reconnexion automatique

- 1.5.3. Créer service de vérification périodique
  • Vérifier les rendez-vous qui auraient dû commencer (décalage de 5-15 minutes)
  • Vérifier les rendez-vous qui auraient dû se terminer
  • Notifier les médecins des rendez-vous non démarrés/terminés
  • Configurer la fréquence d'exécution (toutes les 1-5 minutes)
  • Journaliser les mises à jour automatiques

#### 1.6. SÉCURITÉ ET TESTS BACKEND (CRITIQUE)
- 1.6.1. Tests unitaires pour chaque nouvelle route
- 1.6.2. Tests d'intégration des flux complets
- 1.6.3. Audit de sécurité des nouvelles routes
- 1.6.4. Test de charge pour évaluer les performances
- 1.6.5. Documentation complète des nouvelles APIs

### PHASE 2: SERVICES FRONTEND (1-2 jours)
----------------------------------------

#### 2.1. EXTENSION DU SERVICE appointmentService.js (CRITIQUE)
- 2.1.1. Implémenter startAppointment(appointmentId)
  • Gérer les erreurs réseau et afficher des messages appropriés
  • Implémenter une file d'attente locale pour les actions hors ligne
  • Ajouter mécanisme de retry en cas d'échec

- 2.1.2. Implémenter finishAppointment(appointmentId)
  • Gérer les erreurs réseau et afficher des messages appropriés
  • Implémenter une file d'attente locale pour les actions hors ligne
  • Ajouter mécanisme de retry en cas d'échec

- 2.1.3. Implémenter updateAppointmentNotes(appointmentId, notes)
  • Ajouter sauvegarde automatique périodique (toutes les 30 secondes)
  • Stocker temporairement les notes dans localStorage en cas de déconnexion
  • Gérer les conflits de modification (plusieurs onglets)
  • Implémenter mécanisme d'historique/annulation des modifications

- 2.1.4. Implémenter attachDocumentToAppointment(appointmentId, documentId)
  • Vérifier que le document existe avant association
  • Gérer les erreurs et afficher des messages appropriés
  • Ajouter indicateur visuel pendant le processus d'association

- 2.1.5. Implémenter getAppointmentDocuments(appointmentId)
  • Ajouter support pour pagination et filtrage
  • Mettre en cache les résultats pour améliorer les performances
  • Prévoir la gestion des erreurs

- 2.1.6. Implémenter la configuration WebSocket
  • Établir connexion socket au chargement du service
  • Configurer reconnexion automatique en cas de perte de connexion
  • Définir les gestionnaires d'événements

#### 2.2. MISE À JOUR DU CONTEXTE DoctorAppointmentContext.jsx (CRITIQUE)
- 2.2.1. Ajouter les nouvelles méthodes au contexte
  • Exposer les méthodes du service appointmentService
  • Ajouter l'état et les méthodes pour gérer le rendez-vous actif

- 2.2.2. Gérer les états locaux pour les notes
  • Implémenter un système d'autosave avec indicateurs visuels
  • Gérer les conflits potentiels de modification

- 2.2.3. Gérer les états locaux pour les documents
  • Maintenir une liste à jour des documents associés
  • Gérer les erreurs d'association/récupération

- 2.2.4. Implémenter la logique des WebSockets côté client
  • Écouter les événements de mise à jour de statut
  • Mettre à jour l'interface utilisateur en temps réel
  • Gérer les déconnexions et reconnexions

#### 2.3. TESTS ET SÉCURITÉ FRONTEND (HAUTE)
- 2.3.1. Implémenter les tests unitaires pour les nouveaux services
- 2.3.2. Tester la résilience face aux problèmes réseau
- 2.3.3. Valider la gestion des erreurs
- 2.3.4. Vérifier la sécurité des données en transit

### PHASE 3: INTERFACE UTILISATEUR - AGENDA (2-3 jours)
-----------------------------------------------------

#### 3.1. MODIFICATION DE Agenda.jsx (HAUTE)
- 3.1.1. Ajouter la logique pour détecter les rendez-vous en cours
  • Calculer le temps restant/écoulé pour chaque rendez-vous
  • Implémenter timer en temps réel avec mise à jour toutes les minutes

- 3.1.2. Ajouter un état pour le rendez-vous actif
  • Gérer la sélection/désélection d'un rendez-vous actif
  • Persister la sélection entre les changements de vue

- 3.1.3. Implémenter fonctions de gestion des rendez-vous
  • Fonction pour démarrer un rendez-vous
  • Fonction pour terminer un rendez-vous
  • Gérer les rendez-vous qui se chevauchent
  • Gérer les dépassements de durée prévue

- 3.1.4. Intégrer WebSockets pour mises à jour en temps réel
  • Écouter les événements de changement de statut
  • Mettre à jour l'interface sans rechargement
  • Afficher des notifications pour les changements automatiques

#### 3.2. MISE À JOUR DES INDICATEURS VISUELS (MOYENNE)
- 3.2.1. Modifier AppointmentModals.jsx
  • Afficher clairement le statut actuel
  • Ajouter boutons contextuel selon le statut (démarrer/terminer)
  • Gérer les transitions d'état impossibles (ex: terminé → en cours)

- 3.2.2. Ajouter indicateurs visuels dans les différentes vues
  • Vue jour: Code couleur pour statut + indicateur temps restant
  • Vue semaine: Marqueurs visuels distincts par statut
  • Vue mois: Indicateurs synthétiques pour les statuts
  • Ajouter badge ou marqueur spécial pour rendez-vous en cours

- 3.2.3. Implémenter indicateurs de temps
  • Timer visuel pour le temps écoulé/restant
  • Alerte visuelle pour dépassement de durée prévue
  • Affichage discret des heures de début/fin réelles vs prévues

#### 3.3. CRÉATION DU COMPOSANT ActiveAppointmentModal.jsx (CRITIQUE)
- 3.3.1. Concevoir l'interface principale
  • En-tête avec informations patient et durée du rendez-vous
  • Timer proéminent pour temps restant/écoulé
  • Boutons d'action principaux (terminer, pause, reprendre)

- 3.3.2. Implémenter le formulaire de prise de notes
  • Éditeur de texte riche avec fonctionnalités basiques
  • Sauvegarde automatique périodique avec indicateur visuel
  • Historique des versions/modifications
  • Bouton d'enregistrement manuel
  • Gestion des versions conflictuelles

- 3.3.3. Créer interface pour l'association de documents
  • Liste des documents existants du patient
  • Fonctionnalité de recherche et filtrage
  • Bouton d'association/dissociation
  • Prévisualisation des documents
  • Upload de nouveaux documents

- 3.3.4. Ajouter timer et notifications
  • Timer visuel avec code couleur selon temps restant
  • Alertes pour 5min/1min avant fin prévue
  • Option pour prolonger le rendez-vous si nécessaire
  • Gestion des rendez-vous suivants (notification de conflit)

- 3.3.5. Ajouter fonctionnalités d'accessibilité
  • Raccourcis clavier pour actions fréquentes
  • Support lecteur d'écran pour informations critiques
  • Contrastes suffisants pour éléments importants

#### 3.4. OPTIMISATIONS UX/UI (MOYENNE)
- 3.4.1. Améliorer la réactivité de l'interface
  • Réduire les temps de chargement perçus
  • Ajouter des états de chargement explicites
  • Implémenter la mise en cache intelligente

- 3.4.2. Optimiser pour différents appareils
  • Adapter l'interface pour tablettes (format courant en cabinet)
  • Assurer la compatibilité avec différentes tailles d'écran
  • Tester sur différents navigateurs

- 3.4.3. Implémenter raccourcis et gestes
  • Raccourcis clavier pour actions principales
  • Gestes tactiles pour naviguer dans l'agenda
  • Menu contextuel pour actions rapides

### PHASE 4: TESTS ET RAFFINEMENTS (1-2 jours)
--------------------------------------------

#### 4.1. TESTS MANUELS (CRITIQUE)
- 4.1.1. Tester les transitions de statut
  • Vérifier toutes les transitions possibles
  • Tester les cas où les transitions devraient être bloquées
  • Vérifier les notifications et mises à jour en temps réel

- 4.1.2. Tester les cas limites
  • Rendez-vous à cheval sur deux jours
  • Rendez-vous très courts (<15min)
  • Rendez-vous très longs (>2h)
  • Plusieurs rendez-vous simultanés
  • Rendez-vous consécutifs sans pause

- 4.1.3. Vérifier la persistance des données
  • Vérifier la sauvegarde des notes après actualisation
  • Tester la persistance des associations de documents
  • Vérifier l'historique des modifications

- 4.1.4. Tester les scénarios de déconnexion
  • Simuler une perte de connexion pendant la modification
  • Vérifier la récupération des données après reconnexion
  • Tester le comportement des WebSockets lors des reconnexions

#### 4.2. OPTIMISATIONS DE PERFORMANCE (HAUTE)
- 4.2.1. Optimiser pour grand volume de rendez-vous
  • Tester avec 50+ rendez-vous par jour
  • Améliorer la pagination et le lazy loading
  • Optimiser les requêtes au backend

- 4.2.2. Améliorer système de sauvegarde des notes
  • Implémenter throttling pour réduire les appels API
  • Ajouter compression des données si nécessaire
  • Optimiser la détection des changements

- 4.2.3. Optimiser l'utilisation des WebSockets
  • Réduire le volume de données transmises
  • Implémenter batching pour les mises à jour fréquentes
  • Améliorer la gestion des reconnexions

#### 4.3. AMÉLIORATIONS UX (MOYENNE)
- 4.3.1. Ajouter des notifications pour rendez-vous
  • Notification 15 minutes avant chaque rendez-vous
  • Notification lors des changements automatiques de statut
  • Options de personnalisation des notifications

- 4.3.2. Implémenter des raccourcis clavier
  • Documenter tous les raccourcis disponibles
  • Ajouter une aide contextuelle accessible
  • Permettre la personnalisation des raccourcis

- 4.3.3. Améliorer le retour visuel des actions
  • Animations subtiles pour les transitions de statut
  • Feedback visuel pour toutes les actions importantes
  • Messages de confirmation/erreur améliorés

#### 4.4. DOCUMENTATION ET FORMATION (HAUTE)
- 4.4.1. Mettre à jour la documentation développeur
  • Documenter l'architecture technique
  • Décrire les flux de données et interactions
  • Documenter les tests et procédures de validation

- 4.4.2. Créer documentation utilisateur
  • Guide d'utilisation des nouvelles fonctionnalités
  • Captures d'écran et exemples pratiques
  • FAQ pour problèmes courants

- 4.4.3. Préparer matériel de formation
  • Tutoriels vidéo des principales fonctionnalités
  • Fiches de référence rapide
  • Exemples de cas d'utilisation

## POINTS D'ATTENTION ET RISQUES
-------------------------------

### SÉCURITÉ ET CONFORMITÉ
- Toutes les données médicales doivent être chiffrées en transit et au repos
- L'accès aux notes médicales doit être strictement contrôlé et audité
- Les logs d'accès doivent être conservés pour conformité règlementaire
- Protection contre les attaques CSRF et XSS sur les formulaires

### GESTION DE LA CONCURRENCE
- Risque de conflit si le médecin et le service automatique modifient simultanément un statut
- Nécessité d'implémenter un mécanisme de verrouillage optimiste
- Gestion des modifications simultanées des notes (plusieurs onglets)
- Notifications claires en cas de chevauchement de rendez-vous

### PERFORMANCE ET FIABILITÉ
- Les WebSockets peuvent entraîner une consommation accrue de ressources serveur
- Prévoir mécanisme de dégradation gracieuse si WebSockets indisponibles
- Cache intelligent pour réduire les appels API répétitifs
- Sauvegarde locale pour résistance aux problèmes réseau

### EXPÉRIENCE UTILISATEUR
- Interface doit rester réactive même avec beaucoup de rendez-vous
- Les médecins doivent pouvoir facilement identifier l'état des rendez-vous
- Les transitions entre états doivent être intuitives et rapides
- Prévenir les erreurs utilisateur (ex: terminer accidentellement un rendez-vous)

## RECOMMANDATIONS ADDITIONNELLES
-------------------------------

### ARCHITECTURE ET DÉVELOPPEMENT
- Implémenter un pattern Repository-Service strict pour toute la logique métier
- Centraliser la validation des données dans des middlewares dédiés
- Utiliser des transactions SQL pour toutes les opérations modifiant plusieurs tables
- Créer des tests automatisés pour chaque nouvelle fonctionnalité

### SÉCURITÉ RENFORCÉE
- Mettre en place journalisation détaillée de toutes les actions sur les rendez-vous
- Chiffrer les notes médicales sensibles avec une clé spécifique
- Implémenter un système de détection d'activités suspectes
- Ajouter confirmation pour actions critiques (terminer un rendez-vous)

### OPTIMISATIONS FUTURES
- Prévoir extension pour téléconsultations (statut spécifique)
- Préparer l'intégration avec systèmes de facturation
- Concevoir système de templates pour les notes médicales fréquentes
- Envisager intégration d'IA pour aide à la documentation médicale

### MAINTENANCE ET ÉVOLUTIVITÉ
- Documenter tous les choix d'architecture pour maintenance future
- Prévoir les migrations de données pour évolutions ultérieures
- Mettre en place métriques pour suivre l'utilisation des fonctionnalités
- Planifier revue de code régulière pour assurer qualité
